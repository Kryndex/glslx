namespace GLSLX.Tests {
  def testParser {

# Test constant parsing
test("
void main() {
  int i1 = 0x123;
  int i2 = 0X123;
  int i3 = 0123;

  float f1 = .0;
  float f2 = 0.;
  float f3 = 1e2;
  float f4 = 1e-2;
  float f5 = 1.e2;
  float f6 = .1e-2;
}
", "
void main() {
  int i1 = 291;
  int i2 = 291;
  int i3 = 83;
  float f1 = 0.0;
  float f2 = 0.0;
  float f3 = 100.0;
  float f4 = 0.01;
  float f5 = 100.0;
  float f6 = 1e-3;
}
")

# Test invalid operators
test("
void main() {
  int a = ~1;
  int b = 1 << 2;
  int c = 1 >> 2;
  int d = 1 | 2;
  int e = 1 & 2;
  int f = 1 ^ 2;
  int g = 1 % 2;

  b <<= 3;
  c >>= 3;
  d |= 3;
  e &= 3;
  f ^= 3;
  g %= 3;
}
", "
<stdin>:2:11: error: The operator \"~\" is reserved and cannot be used
  int a = ~1;
          ^
<stdin>:3:13: error: The operator \"<<\" is reserved and cannot be used
  int b = 1 << 2;
            ~~
<stdin>:4:13: error: The operator \">>\" is reserved and cannot be used
  int c = 1 >> 2;
            ~~
<stdin>:5:13: error: The operator \"|\" is reserved and cannot be used
  int d = 1 | 2;
            ^
<stdin>:6:13: error: The operator \"&\" is reserved and cannot be used
  int e = 1 & 2;
            ^
<stdin>:7:13: error: The operator \"^\" is reserved and cannot be used
  int f = 1 ^ 2;
            ^
<stdin>:8:13: error: The operator \"%\" is reserved and cannot be used
  int g = 1 % 2;
            ^
<stdin>:10:5: error: The operator \"<<=\" is reserved and cannot be used
  b <<= 3;
    ~~~
<stdin>:11:5: error: The operator \">>=\" is reserved and cannot be used
  c >>= 3;
    ~~~
<stdin>:12:5: error: The operator \"|=\" is reserved and cannot be used
  d |= 3;
    ~~
<stdin>:13:5: error: The operator \"&=\" is reserved and cannot be used
  e &= 3;
    ~~
<stdin>:14:5: error: The operator \"^=\" is reserved and cannot be used
  f ^= 3;
    ~~
<stdin>:15:5: error: The operator \"%=\" is reserved and cannot be used
  g %= 3;
    ~~
")

# Test comment parsing
test("
// this is a comment
varying vec2 v2;
/*
this is a multi-
line comment
*/
void main() {
  gl_FragColor.xy = v2;
}
", "
varying vec2 v2;

void main() {
  gl_FragColor.xy = v2;
}
")

# Test comment parsing
test("
// this is a comment\r
varying vec2 v2;\r
/*\r
this is a multi-\r
line comment\r
*/\r
void main() {\r
  gl_FragColor.xy = v2;\r
}\r
", "
varying vec2 v2;

void main() {
  gl_FragColor.xy = v2;
}
")

# Test qualifier parsing for arguments
test("
void main(
  attribute float a,
  const float c,
  highp float h,
  in float i,
  inout float io,
  lowp float l,
  mediump float m,
  out float o,
  uniform float u,
  varying float v
) {
}
", "
<stdin>:2:3: error: Cannot use this qualifier here
  attribute float a,
  ~~~~~~~~~
<stdin>:10:3: error: Cannot use this qualifier here
  uniform float u,
  ~~~~~~~
<stdin>:11:3: error: Cannot use this qualifier here
  varying float v
  ~~~~~~~
")

# Test qualifier parsing for global variables
test("
attribute float a;
const float c;
highp float h;
in float i;
inout float io;
lowp float l;
mediump float m;
out float o;
uniform float u;
varying float v;
", "
<stdin>:4:1: error: Cannot use this qualifier here
in float i;
~~
<stdin>:5:1: error: Cannot use this qualifier here
inout float io;
~~~~~
<stdin>:8:1: error: Cannot use this qualifier here
out float o;
~~~
")

# Test qualifier parsing for struct fields
test("
struct Foo {
  attribute float a;
  const float c;
  highp float h;
  in float i;
  inout float io;
  lowp float l;
  mediump float m;
  out float o;
  uniform float u;
  varying float v;
};
", "
<stdin>:2:3: error: Cannot use this qualifier here
  attribute float a;
  ~~~~~~~~~
<stdin>:3:3: error: Cannot use this qualifier here
  const float c;
  ~~~~~
<stdin>:5:3: error: Cannot use this qualifier here
  in float i;
  ~~
<stdin>:6:3: error: Cannot use this qualifier here
  inout float io;
  ~~~~~
<stdin>:9:3: error: Cannot use this qualifier here
  out float o;
  ~~~
<stdin>:10:3: error: Cannot use this qualifier here
  uniform float u;
  ~~~~~~~
<stdin>:11:3: error: Cannot use this qualifier here
  varying float v;
  ~~~~~~~
")

# Test qualifier parsing for local variables
test("
void main() {
  attribute float a;
  const float c = 0.0;
  highp float h;
  in float i;
  inout float io;
  lowp float l;
  mediump float m;
  out float o;
  uniform float u;
  varying float v;
}
", "
<stdin>:5:3: error: Cannot use this qualifier here
  in float i;
  ~~
<stdin>:6:3: error: Cannot use this qualifier here
  inout float io;
  ~~~~~
<stdin>:9:3: error: Cannot use this qualifier here
  out float o;
  ~~~
")

# Test duplicate arguments
test("
void main(int x, int x) {
}
", "
<stdin>:1:22: error: There is already a symbol called \"x\" in the current scope
void main(int x, int x) {
                     ^
<stdin>:1:15: note: The previous definition of \"x\" is here
void main(int x, int x) {
              ^
")

# Test duplicate variables
test("
void main() {
  int x;
  int x;
}
", "
<stdin>:3:7: error: There is already a symbol called \"x\" in the current scope
  int x;
      ^
<stdin>:2:7: note: The previous definition of \"x\" is here
  int x;
      ^
")

# Test duplicate functions
test("
void main() {}
void main() {}
", "
<stdin>:2:6: error: There is already a symbol called \"main\" in the current scope
void main() {}
     ~~~~
<stdin>:1:6: note: The previous definition of \"main\" is here
void main() {}
     ~~~~
")

# Test duplicate structs
test("
struct Foo {};
struct Foo {};
", "
<stdin>:2:8: error: There is already a symbol called \"Foo\" in the current scope
struct Foo {};
       ~~~
<stdin>:1:8: note: The previous definition of \"Foo\" is here
struct Foo {};
       ~~~
")

# Test duplicate fields
test("
struct Foo {
  int x;
  int x;
};
", "
<stdin>:3:7: error: There is already a symbol called \"x\" in the current scope
  int x;
      ^
<stdin>:2:7: note: The previous definition of \"x\" is here
  int x;
      ^
")

# These should not be duplicates
test("
int x;

void main(int x) {
}

void main() {
  int x = 0;
  {
    int x = 0;
    main(x);
  }
}
", "
int x;

void main(int x) {
}

void main() {
  int x = 0;
  {
    int x = 0;
    main(x);
  }
}
")

# Nested struct definitions must be different types
test("
void main() {
  struct S { int x; };
  S a;
  a = a;
  {
    struct S { int x; };
    S b;
    b = b;
    a = b;
    b = a;
  }
}
", "
<stdin>:9:9: error: Cannot convert from type \"S\" to type \"S\"
    a = b;
        ^
<stdin>:10:9: error: Cannot convert from type \"S\" to type \"S\"
    b = a;
        ^
")

# Test invalid array syntax
test("
void main(int[] x) {
}
", "
<stdin>:1:14: error: Expected IDENTIFIER but found LEFT_BRACKET
void main(int[] x) {
             ^
")

# Test invalid array syntax
test("
void main(int[2] x) {
}
", "
<stdin>:1:14: error: Expected IDENTIFIER but found LEFT_BRACKET
void main(int[2] x) {
             ^
")

# Test invalid array syntax
test("
void main() {
  int x[2] = int[](1, 2);
}
", "
<stdin>:2:12: error: Expected SEMICOLON but found ASSIGN
  int x[2] = int[](1, 2);
           ^
")

# Test invalid array syntax
test("
void main() {
  int x[2] = int[2](1, 2);
}
", "
<stdin>:2:12: error: Expected SEMICOLON but found ASSIGN
  int x[2] = int[2](1, 2);
           ^
")

# Test invalid array syntax
test("
void main() {
  int x[2];
  x = int[](1, 2);
}
", "
<stdin>:3:11: error: Unexpected RIGHT_BRACKET
  x = int[](1, 2);
          ^
")

# Test invalid array syntax
test("
void main() {
  int x[2];
  x = int[2](1, 2);
}
", "
<stdin>:3:7: error: Unexpected type \"int\"
  x = int[2](1, 2);
      ~~~
<stdin>:3:5: error: Cannot assign to array type \"int[2]\"
  x = int[2](1, 2);
    ^
")

# Test invalid array syntax
test("
void main() {
  int x[2][2];
}
", "
<stdin>:2:11: error: Expected SEMICOLON but found LEFT_BRACKET
  int x[2][2];
          ^
")

  }
}
