class GLSLX.Resolver {
  const _log Log
  const _data CompilerData
  var _versions List<Node> = []
  var _generatedExtensions StringMap<Node> = {}
  var _returnType Type = null

  def resolveGlobal(global Node) {
    resolveNode(global)

    # Remove all version statements
    for version in _versions {
      version.remove
    }

    # Re-insert the first version statement
    var first = global.firstChild
    if !_versions.isEmpty {
      global.insertChildBefore(first, _versions.first)
    }

    # Insert all automatically generated extensions
    for extension in _generatedExtensions.values {
      global.insertChildBefore(first, extension)
    }
  }

  def resolveNode(node Node) {
    if node.resolvedType != null {
      return
    }

    node.resolvedType = .ERROR

    var kind = node.kind
    switch kind {
      case .GLOBAL {
        _resolveChildren(node)
      }

      case .VARIABLE {
        var symbol = node.symbol.asVariable
        resolveNode(symbol.type)

        # Variables must have a type
        var type = symbol.type.resolvedType
        if type == .VOID {
          _log.semanticErrorBadVariableType(symbol.type.range, type)
          type = .ERROR
        }

        # Array size
        if symbol.arrayCount != null {
          _resolveAsExpression(symbol.arrayCount)
          checkConversion(symbol.arrayCount, .INT)
        }

        # Initial value
        if symbol.value != null {
          _resolveAsExpression(symbol.value)
          checkConversion(symbol.value, type)
        }

        # Constants must be initialized
        if symbol.kind == .LOCAL && symbol.isConst {
          if symbol.value != null {
            var folded = Folder.fold(symbol.value)
            if folded == null {
              _log.syntaxErrorConstantRequired(symbol.value.range)
            } else {
              assert(folded.parent == null)
              assert(folded.resolvedType != null)
              symbol.constantValue = folded
            }
          } else {
            _log.semanticErrorUninitializedConstant(symbol.range)
          }
        }
      }

      case .BLOCK {
        _resolveChildren(node)
      }

      case .BREAK, .CONTINUE, .DISCARD {
      }

      case .DO_WHILE {
        resolveNode(node.doWhileBody)
        resolveNode(node.doWhileTest)
        checkConversion(node.doWhileTest, .BOOL)
      }

      case .EXPRESSION {
        resolveNode(node.expressionValue)
      }

      case .EXTENSION {
      }

      case .FOR {
        if node.forSetup != null {
          _resolveAsExpression(node.forSetup)
        }
        if node.forTest != null {
          _resolveAsExpression(node.forTest)
          checkConversion(node.forTest, .BOOL)
        }
        if node.forUpdate != null {
          _resolveAsExpression(node.forUpdate)
        }
        resolveNode(node.forBody)
      }

      case .FUNCTION {
        var symbol = node.symbol.asFunction
        for argument in symbol.arguments {
          resolveNode(argument.type)
        }
        resolveNode(symbol.returnType)
        if symbol.block != null {
          _returnType = symbol.returnType.resolvedType
          resolveNode(symbol.block)
          _returnType = null
        }
      }

      case .IF {
        resolveNode(node.ifTest)
        checkConversion(node.ifTest, .BOOL)
        resolveNode(node.ifTrue)
        if node.ifFalse != null {
          resolveNode(node.ifFalse)
        }
      }

      case .PRECISION {
      }

      case .RETURN {
        if node.returnValue != null {
          resolveNode(node.returnValue)
          checkConversion(node.returnValue, _returnType)
        } else {
          node.resolvedType = .VOID
          checkConversion(node, _returnType)
        }
      }

      case .STRUCT {
        _resolveChildren(node)
      }

      case .VARIABLES {
        _resolveChildren(node)
      }

      case .VERSION {
        _versions.append(node)
      }

      case .WHILE {
        resolveNode(node.whileTest)
        checkConversion(node.whileTest, .BOOL)
        resolveNode(node.whileBody)
      }

      case .CALL {
        _resolveCall(node)
      }

      case .DOT {
        _resolveDot(node)
      }

      case .HOOK {
        var test = node.hookTest
        var no = node.hookFalse
        var yes = node.hookTrue

        _resolveAsExpression(test)
        checkConversion(test, .BOOL)
        _resolveAsExpression(yes)
        _resolveAsExpression(no)

        if yes.resolvedType != no.resolvedType {
          _log.semanticErrorBadHookTypes(Range.span(yes.range, no.range), yes.resolvedType, no.resolvedType)
        } else {
          node.resolvedType = yes.resolvedType
        }
      }

      case .NAME {
        var symbol = node.symbol

        if symbol.isVariable {
          resolveNode(symbol.asVariable.type)
          node.resolvedType = symbol.asVariable.type.resolvedType
        }

        else if symbol.isFunction && !node.isCallTarget {
          _log.semanticErrorMustCallFunction(node.range, symbol.name)
        }

        else {
          node.resolvedType = symbol.resolvedType
        }

        # Make sure the extension is enabled if it hasn't been specified
        var name = symbol.requiredExtension
        if name != null && !(name in _generatedExtensions) && _data.extensionBehavior(name) == .DEFAULT {
          _generatedExtensions[name] = Node.createExtension(name, .ENABLE)
        }
      }

      case .SEQUENCE {
        for child = node.firstChild; child != null; child = child.nextSibling {
          _resolveAsExpression(child)
        }
        node.resolvedType = node.lastChild.resolvedType
      }

      default {
        if kind.isUnary { _resolveUnary(node) }
        else if kind.isBinary { _resolveBinary(node) }
        else { assert(false) }
      }
    }

    assert(node.resolvedType != null)
  }

  def _resolveUnary(node Node) {
    var value = node.unaryValue

    _resolveAsExpression(value)

    if node.kind.isUnaryAssign {
      _checkStorage(value)
    }

    var valueType = value.resolvedType

    switch node.kind {
      case .NEGATIVE, .POSITIVE, .PREFIX_DECREMENT, .PREFIX_INCREMENT, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT {
        node.resolvedType =
          valueType.isIntOrFloat ? valueType :
          .ERROR
      }

      case .NOT {
        node.resolvedType =
          valueType == .BOOL ? .BOOL :
          .ERROR
      }
    }

    if node.resolvedType == .ERROR && valueType != .ERROR {
      _log.semanticErrorBadUnary(node.internalRange, node.internalRange.toString, valueType)
    }
  }

  def _resolveBinary(node Node) {
    var left = node.binaryLeft
    var right = node.binaryRight

    _resolveAsExpression(left)
    _resolveAsExpression(right)

    if node.kind.isBinaryAssign {
      _checkStorage(left)
    }

    var leftType = left.resolvedType
    var rightType = right.resolvedType
    var isSame = leftType == rightType

    switch node.kind {
      case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE {
        node.resolvedType =
          isSame && leftType.isBoolOrIntOrFloat ? leftType :

          leftType.isFloat && rightType == .FLOAT ? leftType :
          leftType.isInt && rightType == .INT ? leftType :

          leftType == .FLOAT && rightType.isFloat ? rightType :
          leftType == .INT && rightType.isInt ? rightType :

          node.kind == .MULTIPLY && (leftType == .VEC2 && rightType == .MAT2 || leftType == .MAT2 && rightType == .VEC2) ? .VEC2 :
          node.kind == .MULTIPLY && (leftType == .VEC3 && rightType == .MAT3 || leftType == .MAT3 && rightType == .VEC3) ? .VEC3 :
          node.kind == .MULTIPLY && (leftType == .VEC4 && rightType == .MAT4 || leftType == .MAT4 && rightType == .VEC4) ? .VEC4 :

          .ERROR
      }

      case .EQUAL, .NOT_EQUAL {
        node.resolvedType =
          isSame ? .BOOL :
          .ERROR
      }

      case .LOGICAL_AND, .LOGICAL_OR, .LOGICAL_XOR {
        node.resolvedType =
          isSame && leftType == .BOOL ? .BOOL :
          .ERROR
      }

      case .LESS_THAN, .LESS_THAN_OR_EQUAL, .GREATER_THAN, .GREATER_THAN_OR_EQUAL {
        node.resolvedType =
          isSame && (leftType == .FLOAT || leftType == .INT) ? .BOOL :
          .ERROR
      }

      case .ASSIGN {
        node.resolvedType = leftType
        checkConversion(right, leftType)
        return
      }

      case .ASSIGN_ADD, .ASSIGN_SUBTRACT, .ASSIGN_MULTIPLY, .ASSIGN_DIVIDE {
        node.resolvedType =
          isSame && leftType.isBoolOrIntOrFloat ? leftType :

          leftType.isFloat && rightType == .FLOAT ? leftType :
          leftType.isInt && rightType == .INT ? leftType :

          node.kind == .ASSIGN_MULTIPLY && (
            leftType == .VEC2 && rightType == .MAT2 ||
            leftType == .VEC3 && rightType == .MAT3 ||
            leftType == .VEC4 && rightType == .MAT4) ? leftType :

          .ERROR
      }

      case .INDEX {
        if rightType == .INT {
          var indexType = leftType.indexType
          if indexType != null {
            node.resolvedType = indexType
          }

          # Run bounds checking on the constant-folded value
          var folded = Folder.fold(right)
          if folded != null && folded.kind == .INT {
            var value = folded.asInt
            var count = leftType.indexCount

            # Negative indices are always invalid even if the array size is unknown
            if value < 0 || count != 0 && value >= count {
              _log.semanticErrorOutOfBoundsIndex(right.range, value, leftType)
            }
          }
        }
      }
    }

    # If we get here, show an error about an invalid operator
    if node.resolvedType == .ERROR && leftType != .ERROR && rightType != .ERROR {
      if node.kind == .INDEX {
        _log.semanticErrorBadIndex(node.internalRange, leftType, rightType)
      } else {
        _log.semanticErrorBadBinary(node.internalRange, node.internalRange.toString, leftType, rightType)
      }
    }
  }

  def _resolveCall(node Node) {
    var callTarget = node.callTarget
    resolveNode(callTarget)

    var type = callTarget.resolvedType
    var symbol = type.symbol
    var arguments List<Node> = []
    var hasError = false

    for child = callTarget.nextSibling; child != null; child = child.nextSibling {
      _resolveAsExpression(child)
      arguments.append(child)
      if child.resolvedType == .ERROR {
        hasError = true
      }
    }

    if hasError {
      return
    }

    if symbol != null {
      if symbol.isFunction {
        _resolveFunctionOverloads(symbol.asFunction, node, arguments)
        return
      }

      if symbol.isStruct {
        _resolveConstructor(type, node, arguments)
        return
      }
    }

    if type != .ERROR {
      _log.semanticErrorBadCall(callTarget.range, type)
    }
  }

  def _resolveDot(node Node) {
    var dotTarget = node.dotTarget
    var name = node.asString
    var range = node.internalRange
    _resolveAsExpression(dotTarget)

    var type = dotTarget.resolvedType
    var isAssignTarget = node.isAssignTarget
    switch type {
      case .BVEC2, .IVEC2, .VEC2, .BVEC3, .IVEC3, .VEC3, .BVEC4, .IVEC4, .VEC4 {
        node.resolvedType = _validateSwizzle(range, type, name, isAssignTarget)
      }

      default {
        if type.symbol != null && type.symbol.isStruct {
          for variable in type.symbol.asStruct.variables {
            if variable.name == name {
              node.symbol = variable
              resolveNode(variable.type)
              node.resolvedType = variable.type.resolvedType
              break
            }
          }
        }

        if node.symbol == null {
          _log.semanticErrorBadMember(range, type, name)
        }
      }
    }
  }

  def _resolveFunctionOverloads(overloaded FunctionSymbol, node Node, arguments List<Node>) {
    var overloads List<FunctionSymbol> = []

    for overload = overloaded; overload != null; overload = overload.previousOverload {
      overloads.append(overload)
    }

    # Narrow down by argument count
    if overloads.count != 1 {
      overloads = overloads.clone
      overloads.removeIf(overload => overload.arguments.count != arguments.count)

      # Narrow down by argument types
      if overloads.count != 1 {
        var overloadsBeforeTypeFilter = overloads.clone
        overloads.removeIf(overload => {
          for i in 0..arguments.count {
            if overload.arguments[i].type.resolvedType != arguments[i].resolvedType {
              return true
            }
          }
          return false
        })

        # Narrow down by argument types with "conversions" to get better error messages
        if overloads.count != 1 {
          overloads = overloadsBeforeTypeFilter
          overloads.removeIf(overload => {
            for i in 0..arguments.count {
              var from = overload.arguments[i].type.resolvedType
              var to = arguments[i].resolvedType
              var fromSize = from.componentCount
              var toSize = to.componentCount
              if from != to && (fromSize == 0 || toSize == 0 || fromSize != toSize) {
                return true
              }
            }
            return false
          })
        }
      }
    }

    # Match failure
    if overloads.count != 1 {
      _log.semanticErrorBadOverloadMatch(node.callTarget.range, overloaded.name)
      return
    }

    # Match success
    var overload = overloads.first
    if overload.arguments.count != arguments.count {
      _log.semanticErrorArgumentCountFunction(node.internalRange, overload.arguments.count,
        arguments.count, overload.name, overload.range)
    } else {
      for i in 0..arguments.count {
        checkConversion(arguments[i], overload.arguments[i].type.resolvedType)
      }
    }
    node.callTarget.symbol = overload
    node.resolvedType = overload.returnType.resolvedType
  }

  def _resolveConstructor(type Type, node Node, arguments List<Node>) {
    node.resolvedType = type

    if type == .ERROR {
      return
    }

    if type.isBoolOrIntOrFloat {
      var count = type.componentCount

      # Visit each argument and make sure it's useful toward construction
      var providedCount = 0
      for argument in arguments {
        var argumentType = argument.resolvedType
        if !(argumentType.isBoolOrIntOrFloat) {
          if argumentType != .ERROR {
            _log.semanticErrorBadConstructorValue(argument.range, argumentType, type)
          }
          return
        }
        providedCount += argumentType.componentCount
      }

      # Passing extra values to a constructor is allowed
      if providedCount > count {
        _log.semanticWarningExtraConstructorValues(node.internalRange, type, providedCount, count)
      }

      # Validate the count (matrices also have special diagonal constructors)
      else if providedCount != count && providedCount != 1 &&
          (providedCount != 2 || type != .MAT2) &&
          (providedCount != 3 || type != .MAT3) &&
          (providedCount != 4 || type != .MAT4) {
        _log.semanticErrorBadConstructorCount(node.internalRange, type, providedCount)
      }

      return
    }

    var symbol = type.symbol.asStruct
    var variables = symbol.variables
    var variableCount = variables.count
    var argumentCount = arguments.count

    # Validate argument count
    if variableCount != argumentCount {
      _log.semanticErrorArgumentCountConstructor(node.internalRange, variableCount, argumentCount, symbol.name, symbol.range)
      return
    }

    # Validate argument types
    for i in 0..variableCount {
      checkConversion(arguments[i], variables[i].type.resolvedType)
    }
  }

  def _validateSwizzle(range Range, type Type, name string, isAssignTarget bool) Type {
    var count = name.count
    if count > 4 {
      _log.semanticErrorBadSwizzle(range, type, name)
      return .ERROR
    }

    var componentCount = type.componentCount
    for set in Swizzle.strings(componentCount) {
      if name.get(0) in set {
        for i in 1..count {
          if !(name.get(i) in set) {
            _log.semanticErrorBadSwizzle(range, type, name)
            return .ERROR
          }
          if isAssignTarget && name.get(i) in name.slice(0, i) {
            _log.semanticErrorBadSwizzleAssignment(range.slice(i, i + 1), name.get(i))
            return .ERROR
          }
        }
        return Swizzle.type(type.componentType, count)
      }
    }

    _log.semanticErrorBadSwizzle(range, type, name)
    return .ERROR
  }

  def _resolveAsExpression(node Node) {
    resolveNode(node)
    if node.kind == .TYPE && node.resolvedType != .ERROR {
      _log.semanticErrorUnexpectedType(node.range, node.resolvedType)
      node.resolvedType = .ERROR
    }
  }

  def _resolveChildren(node Node) {
    for child = node.firstChild; child != null; child = child.nextSibling {
      resolveNode(child)
    }
  }

  def _checkStorage(node Node) {
    var n = node
    assert(node.kind.isExpression)

    while true {
      switch n.kind {
        case .NAME {
          if n.symbol.isConst {
            _log.semanticErrorBadStorage(node.range)
          }
          break
        }

        case .DOT {
          n = n.dotTarget
        }

        case .INDEX {
          n = n.binaryLeft
        }

        default {
          _log.semanticErrorBadStorage(node.range)
          break
        }
      }
    }
  }

  def checkConversion(node Node, type Type) {
    if node.resolvedType != type && node.resolvedType != .ERROR && type != .ERROR {
      _log.semanticErrorBadConversion(node.range, node.resolvedType, type)
      node.resolvedType = .ERROR
    }
  }
}
