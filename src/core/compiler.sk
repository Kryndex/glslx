namespace GLSLX {
  class CompilerOptions {
    var renameInternalSymbols = false
    var compactSyntaxTree = false
    var removeWhitespace = false
    var exportMultiple = false
    var trimVariables = false
  }

  enum ExtensionBehavior {
    DEFAULT
    DISABLE
    ENABLE
    REQUIRE
    WARN
  }

  class CompilerData {
    const currentExtensions StringMap<ExtensionBehavior> = {}
    var _nextSymbolID = 0

    def nextSymbolID int {
      _nextSymbolID++
      return _nextSymbolID
    }

    def extensionBehavior(name string) ExtensionBehavior {
      return currentExtensions.get(name, .DEFAULT)
    }
  }

  class CompilerResult {
    const shaders List<Source>
    const renaming StringMap<string>
  }
}

namespace GLSLX.Compiler {
  def compile(log Log, sources List<Source>, options CompilerOptions) CompilerResult {
    if log.hasErrors {
      return null
    }

    # Generate tokens once
    sources.prepend(Source.new("<api>", API))
    for source in sources {
      source.tokens = Tokenizer.tokenize(log, source)
    }
    if log.hasErrors {
      return null
    }

    var global = Node.createGlobal
    var scope = Scope.new(.GLOBAL, null)
    var data = CompilerData.new

    # Parse everything next
    for source in sources {
      Parser.parse(log, source.tokens, global, data, scope)
      if source == sources.first {
        _markGlobalSymbolsAsImported(scope)
      }
    }
    if log.hasErrors {
      return null
    }

    # Then run type checking
    Resolver.resolve(log, global, data)
    if log.hasErrors {
      return null
    }

    # Imported symbols are just there for type checking and shouldn't be emitted
    _removeImportedSymbols(global)

    # Multiple export mode is more complicated. Everything is already compiled,
    # and in theory we could quickly export all shaders from that, but in
    # practice it's simpler if the source code is just compiled over again once
    # per shader.
    var shaders List<Source> = []
    for root in _collectAllExportedFunctions(scope) {
      var shaderGlobal = Node.createGlobal
      var shaderScope = Scope.new(.GLOBAL, null)
      var shaderData = CompilerData.new
      var shaderLog = Log.new

      # Parse everything again
      for source in sources {
        Parser.parse(shaderLog, source.tokens, shaderGlobal, shaderData, shaderScope)
        if source == sources.first {
          _markGlobalSymbolsAsImported(shaderScope)
        }
      }

      # Flow types through the tree
      Resolver.resolve(shaderLog, shaderGlobal, shaderData)

      # Optimize it and trim it down
      _removeImportedSymbols(shaderGlobal)
      _unexportAllFunctionsExcept(shaderScope, root)
      Rewriter.rewrite(shaderGlobal, options)

      # TODO: Need to rename everything together

      # Generate the code for this shader
      Rewriter.rewrite(shaderGlobal, options)
      Renamer.rename(shaderGlobal, options)
      shaders.append(Source.new(root.name, Emitter.emit(shaderGlobal, options)))
    }

    return CompilerResult.new(shaders, null)
  }

  def _markGlobalSymbolsAsImported(scope Scope) {
    for symbol in scope.symbols.values {
      if symbol.isFunction {
        for function = symbol.asFunction; function != null; function = function.previousOverload {
          function.flags |= Symbol.IMPORTED
        }
      } else {
        symbol.flags |= Symbol.IMPORTED
      }
    }
  }

  def _collectAllExportedFunctions(scope Scope) List<FunctionSymbol> {
    var symbols List<FunctionSymbol> = []
    for symbol in scope.symbols.values {
      if symbol.isFunction && symbol.isExported {
        symbols.append(symbol.asFunction)
      }
    }
    return symbols
  }

  def _unexportAllFunctionsExcept(scope Scope, function FunctionSymbol) {
    for symbol in scope.symbols.values {
      if symbol.id != function.id {
        symbol.flags &= ~Symbol.EXPORTED
      }
    }
  }

  def _removeImportedSymbols(global Node) {
    for child = global.firstChild, nextChild Node = null; child != null; child = nextChild {
      nextChild = child.nextSibling

      if (child.kind == .FUNCTION || child.kind == .STRUCT) && child.symbol.isImported {
        child.remove
      }

      else if child.kind == .VARIABLES {
        for variable = child.variablesType.nextSibling, nextVariable Node = null; variable != null; variable = nextVariable {
          nextVariable = variable.nextSibling
          assert(variable.kind == .VARIABLE)

          if variable.symbol.isImported {
            variable.remove
          }
        }

        if child.variablesType.nextSibling == null {
          child.remove
        }
      }
    }
  }
}
