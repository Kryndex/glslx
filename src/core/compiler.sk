namespace GLSLX {
  class CompilerOptions {
    var renameInternalSymbols = false
    var trimLocalVariables = false
    var compactSyntaxTree = false
    var removeWhitespace = false
  }

  enum ExtensionBehavior {
    DEFAULT
    DISABLE
    ENABLE
    REQUIRE
    WARN
  }

  class CompilationData {
    const currentExtensions StringMap<ExtensionBehavior> = {}

    def extensionBehavior(name string) ExtensionBehavior {
      return currentExtensions.get(name, .DEFAULT)
    }
  }
}

namespace GLSLX.Compiler {
  def compile(log Log, source Source, options CompilerOptions) string {
    if log.hasErrors {
      return null
    }

    var apiTokens = Tokenizer.tokenize(log, Source.new("api.glsl", API))
    var sourceTokens = Tokenizer.tokenize(log, source)

    if log.hasErrors {
      return null
    }

    var global = Node.createGlobal
    var scope = Scope.new(.GLOBAL, null)
    var data = CompilationData.new

    Parser.parse(log, apiTokens, global, data, scope)

    for symbol in scope.symbols.values {
      if symbol.isFunction {
        for function = symbol.asFunction; function != null; function = function.previousOverload {
          function.flags |= Symbol.IMPORTED
        }
      } else {
        symbol.flags |= Symbol.IMPORTED
      }
    }

    Parser.parse(log, sourceTokens, global, data, scope)

    if log.hasErrors {
      return null
    }

    Resolver.resolve(log, global, data)

    if log.hasErrors {
      return null
    }

    # Imported symbols are just there for type checking and shouldn't be emitted
    removeImportedSymbols(global)

    Rewriter.rewrite(global, options)
    Renamer.rename(global, options)
    return Emitter.emit(global, options)
  }

  def removeImportedSymbols(node Node) {
    for child = node.firstChild, nextChild Node = null; child != null; child = nextChild {
      nextChild = child.nextSibling

      if (child.kind == .FUNCTION || child.kind == .STRUCT) && child.symbol.isImported {
        child.remove
      }

      else if child.kind == .VARIABLES {
        for variable = child.variablesType.nextSibling, nextVariable Node = null; variable != null; variable = nextVariable {
          nextVariable = variable.nextSibling
          assert(variable.kind == .VARIABLE)

          if variable.symbol.isImported {
            variable.remove
          }
        }

        if child.variablesType.nextSibling == null {
          child.remove
        }
      }
    }
  }
}
